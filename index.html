<!DOCTYPE html>
<html>
<head>
    <title>Optimized Terrain Generator</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #222;
            touch-action: none;
            user-select: none;
        }
        #heightmap {
            position: absolute;
            top: 0;
            left: 0;
            /* width/height determined by grid */
            display: grid;
             /* Allow panning via top/left */
            will-change: transform;
        }
        .tile {
            transition: background-color 0.15s ease-out;
            box-sizing: border-box;
            /* border: 1px solid rgba(255,255,255,0.05); */ /* Optional: visualize tiles */
        }
        #controls {
            position: fixed;
            top: 8px;
            left: 8px;
            background-color: rgba(30, 30, 30, 0.92);
            padding: 10px 12px;
            border-radius: 5px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.6);
            width: 280px;
            max-height: calc(94vh - 30px);
            overflow-y: auto;
            z-index: 100;
            color: #eee;
            font-size: 13px;
            transition: transform 0.3s ease-in-out, margin-left 0.3s ease-in-out;
        }
        #controls.collapsed {
            transform: translateX(-100%);
            margin-left: -15px;
            box-shadow: none;
        }
        #toggle-controls {
            position: fixed;
            top: 8px;
            left: calc(8px + 280px + 12px + 8px);
            z-index: 101;
            background-color: #4a6b3e;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 0 4px 4px 0;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: left 0.3s ease-in-out, background-color 0.15s;
        }
        #toggle-controls:hover {
            background-color: #5a7c4e;
        }
        #controls.collapsed + #toggle-controls {
             left: 8px;
             border-radius: 4px;
        }
        .control-group {
            margin-bottom: 8px;
        }
        label {
            display: block;
            margin-bottom: 2px;
            font-weight: bold;
            color: #ddd;
        }
        input[type="range"] {
            width: 100%;
            height: 16px;
            background: #444;
            margin: 4px 0;
        }
        input[type="color"] {
            width: 28px;
            height: 20px;
            padding: 0 1px;
            border: 1px solid #555;
            vertical-align: middle;
        }
        select, button#regenerate {
            width: 100%;
            padding: 6px;
            margin: 6px 0;
            background: #444;
            color: white;
            border: 1px solid #555;
            border-radius: 3px;
            font-size: 13px;
        }
        button#regenerate {
            background-color: #4a6b3e;
            border: none;
            padding: 8px;
            cursor: pointer;
            transition: background-color 0.15s;
        }
        button#regenerate:hover {
            background-color: #5a7c4e;
        }
        .value-display {
            font-size: 11px;
            color: #aaa;
            text-align: right;
            margin-top: -2px;
        }
        .color-preview {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 1px solid #555;
            margin-right: 6px;
            vertical-align: middle;
            border-radius: 2px;
        }
        .section-title {
            font-weight: bold;
            margin: 12px 0 6px 0;
            padding-bottom: 3px;
            border-bottom: 1px solid #444;
            color: #ddd;
            font-size: 13px;
        }
        #position-display {
            position: fixed;
            bottom: 8px;
            right: 8px;
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 6px 10px;
            border-radius: 3px;
            font-size: 11px;
            font-family: monospace;
            z-index: 99;
        }
        #help-text {
            position: fixed;
            bottom: 8px;
            left: 310px; /* Initial position next to controls */
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 6px 10px;
            border-radius: 3px;
            font-size: 11px;
            max-width: 200px;
            line-height: 1.4;
            transition: left 0.3s ease-in-out;
            z-index: 99; /* Below controls */
        }
         #controls.collapsed ~ #help-text {
             left: 8px; /* Move help text to edge when controls collapsed */
        }
        .compact-row {
            display: flex;
            gap: 10px;
        }
        .compact-row > div {
            flex: 1;
        }
    </style>
</head>
<body>
    <div id="heightmap"></div>

    <div id="controls">
        <select id="preset-select">
            <option value="bw">B/W Perlin</option>
            <option value="terrain">Basic Terrain</option>
            <option value="atlas" selected>Advanced Atlas</option>
            <option value="realistic">Realistic Earth</option>
            <option value="mars">Mars</option>
            <option value="islands">Islands</option>
        </select>

        <div class="section-title">VIEW</div>
        <!-- Removed Zoom Control -->
        <div class="control-group"> <!-- Changed layout as zoom is removed -->
            <label for="gridDensity">Tile Size</label>
            <input type="range" id="gridDensity" min="10" max="60" value="30">
            <div class="value-display"><span id="gridDensityValue">30</span>px</div>
        </div>

        <div class="section-title">TERRAIN</div>
        <div class="compact-row">
            <div class="control-group">
                <label for="heightRange">Height Scale</label> <!-- Renamed label for clarity -->
                <input type="range" id="heightRange" min="0.5" max="2.0" step="0.1" value="1.0"> <!-- Changed range/step for scale -->
                <div class="value-display"><span id="heightRangeValue">1.0</span>x</div>
            </div>
            <div class="control-group">
                <label for="seaLevel">Sea Level</label>
                <input type="range" id="seaLevel" min="0.1" max="0.7" step="0.01" value="0.35">
                <div class="value-display"><span id="seaLevelValue">0.35</span></div>
            </div>
        </div>

        <div class="section-title">NOISE</div>
        <div class="compact-row">
            <div class="control-group">
                <label for="noiseScale">Scale</label>
                <input type="range" id="noiseScale" min="20" max="500" value="150">
                <div class="value-display"><span id="noiseScaleValue">150</span></div>
            </div>
            <div class="control-group">
                <label for="octaves">Octaves</label>
                <input type="range" id="octaves" min="1" max="8" value="4">
                <div class="value-display"><span id="octavesValue">4</span></div>
            </div>
        </div>
        <div class="compact-row">
            <div class="control-group">
                <label for="persistence">Persistence</label>
                <input type="range" id="persistence" min="0.1" max="0.9" step="0.05" value="0.6">
                <div class="value-display"><span id="persistenceValue">0.60</span></div>
            </div>
            <div class="control-group">
                <label for="lacunarity">Lacunarity</label>
                <input type="range" id="lacunarity" min="1.1" max="4" step="0.1" value="2">
                <div class="value-display"><span id="lacunarityValue">2.0</span></div>
            </div>
        </div>

        <div class="section-title">COLORS</div>
        <div class="compact-row">
            <div class="control-group">
                <label><span class="color-preview" id="previewDeepWater" style="background: #0f2c4a;"></span>Deep</label>
                <input type="color" id="colorDeepWater" value="#0f2c4a">
            </div>
            <div class="control-group">
                <label><span class="color-preview" id="previewShallowWater" style="background: #1a4a7a;"></span>Shallow</label>
                <input type="color" id="colorShallowWater" value="#1a4a7a">
            </div>
            <div class="control-group">
                <label><span class="color-preview" id="previewSand" style="background: #e8d5a8;"></span>Sand</label>
                <input type="color" id="colorSand" value="#e8d5a8">
            </div>
        </div>
        <div class="compact-row">
            <div class="control-group">
                <label><span class="color-preview" id="previewGrass" style="background: #6b8c42;"></span>Grass</label>
                <input type="color" id="colorGrass" value="#6b8c42">
            </div>
            <div class="control-group">
                <label><span class="color-preview" id="previewForest" style="background: #3a5a2a;"></span>Forest</label>
                <input type="color" id="colorForest" value="#3a5a2a">
            </div>
            <div class="control-group">
                <label><span class="color-preview" id="previewRock" style="background: #6a5a4a;"></span>Rock</label>
                <input type="color" id="colorRock" value="#6a5a4a">
            </div>
        </div>
         <div class="compact-row">
             <div class="control-group">
                <label><span class="color-preview" id="previewSnow" style="background: #d0e0f0;"></span>Snow</label>
                <input type="color" id="colorSnow" value="#d0e0f0">
            </div>
            <div></div><!-- Spacer -->
            <div></div><!-- Spacer -->
         </div>

        <button id="regenerate">Generate New Seed</button>
    </div>

    <button id="toggle-controls" title="Toggle Controls Panel (C)">◀</button>

    <div id="position-display">X: 0, Y: 0</div> <!-- Removed Zoom -->
    <div id="help-text">Arrows/WASD: Pan<br>R: New Seed<br>C: Toggle Controls<br>Drag: Pan</div> <!-- Removed Zoom Help -->

    <script>
        // Optimized Perlin noise generator (remains the same)
        class PerlinNoise {
             constructor(seed) {
                this.seed = seed || Math.random() * 999999;
                this.gradients = new Map();
                this._s = this.seed; // Use separate state for PRNG
            }

             _random() {
                this._s ^= this._s >> 12;
                this._s ^= this._s << 25;
                this._s ^= this._s >> 27;
                // Multiply by a large prime number and take the lower 53 bits for a float
                return (this._s * 0x2545F4914F6CDD1D) / Math.pow(2, 64) + 0.5; // Ensure positive float 0..1
            }

            getGradient(x, y) {
                const key = `${x}|${y}`;
                if (!this.gradients.has(key)) {
                    const angle = this._random() * Math.PI * 2;
                    this.gradients.set(key, [Math.cos(angle), Math.sin(angle)]);
                }
                return this.gradients.get(key);
            }

            get(x, y) {
                const x0 = Math.floor(x), y0 = Math.floor(y);
                const x1 = x0 + 1, y1 = y0 + 1;

                const g00 = this.getGradient(x0, y0);
                const g10 = this.getGradient(x1, y0);
                const g01 = this.getGradient(x0, y1);
                const g11 = this.getGradient(x1, y1);

                const d00 = [x - x0, y - y0];
                const d10 = [x - x1, y - y0];
                const d01 = [x - x0, y - y1];
                const d11 = [x - x1, y - y1];

                const p00 = d00[0] * g00[0] + d00[1] * g00[1];
                const p10 = d10[0] * g10[0] + d10[1] * g10[1];
                const p01 = d01[0] * g01[0] + d01[1] * g01[1];
                const p11 = d11[0] * g11[0] + d11[1] * g11[1];

                const sx = x - x0;
                const sy = y - y0;
                const u = sx * sx * sx * (sx * (sx * 6 - 15) + 10);
                const v = sy * sy * sy * (sy * (sy * 6 - 15) + 10);

                // Clamp interpolation factor just in case
                const lerpVal = this._lerp(
                    this._lerp(p00, p10, u),
                    this._lerp(p01, p11, u),
                    v
                );
                // Perlin noise theoretical range is ~[-sqrt(N/4), sqrt(N/4)] where N is dimensions (2)
                // So range is roughly [-0.707, 0.707]. Normalize closer to -1 to 1.
                return Math.max(-1, Math.min(1, lerpVal * 1.4));
            }

            _lerp(a, b, t) {
                return a + t * (b - a);
            }
        }

        class TerrainGenerator {
            constructor() {
                this.MAX_OCTAVES = 8;
                this.BASE_MOVE_SPEED = 450; // Adjusted pixels per second

                this.initNoise();
                this.initParams();
                this.initDOM();
                this.initEvents();

                this.keysPressed = {};
                this.lastTimestamp = 0;
                this.needsRender = true;
                this.renderDebounce = null;
                this.animationFrameId = null;

                this.updateLoop(performance.now());
            }

            initNoise() {
                this.perlin = new PerlinNoise(Date.now());
                this.lastSeed = Date.now();
                // Clear gradient cache on new seed
                this.perlin.gradients.clear();
            }

            initParams() {
                this.view = {
                    x: 0, y: 0,
                    // zoom: 1, // Zoom removed
                    isDragging: false, lastX: 0, lastY: 0
                };

                this.params = {
                    gridDensity: 30,
                    heightRange: 1.0, // Now a multiplier for noise output
                    noiseScale: 150,
                    octaves: 4,
                    persistence: 0.6,
                    lacunarity: 2,
                    seaLevel: 0.35,
                    colorMode: 'atlas',
                    colors: {
                        deepWater: '#0f2c4a', shallowWater: '#1a4a7a', sand: '#e8d5a8',
                        grass: '#6b8c42', forest: '#3a5a2a', rock: '#6a5a4a', snow: '#d0e0f0'
                    },
                    biomeRanges: {}
                };

                this.updateBiomeRanges();
            }

            initDOM() {
                document.getElementById('gridDensity').value = this.params.gridDensity;
                // document.getElementById('zoom').value = this.view.zoom; // Removed
                document.getElementById('heightRange').value = this.params.heightRange;
                document.getElementById('seaLevel').value = this.params.seaLevel;
                document.getElementById('noiseScale').value = this.params.noiseScale;
                document.getElementById('octaves').value = this.params.octaves;
                document.getElementById('persistence').value = this.params.persistence;
                document.getElementById('lacunarity').value = this.params.lacunarity;

                const colorIds = ['DeepWater', 'ShallowWater', 'Sand', 'Grass', 'Forest', 'Rock', 'Snow'];
                colorIds.forEach(id => {
                    const key = id.charAt(0).toLowerCase() + id.slice(1);
                    if(document.getElementById(`color${id}`)) {
                         document.getElementById(`color${id}`).value = this.params.colors[key];
                    }
                   if(document.getElementById(`preview${id}`)) {
                       document.getElementById(`preview${id}`).style.backgroundColor = this.params.colors[key];
                   }
                });

                this.updateValueDisplays();
            }

            updateValueDisplays() {
                document.getElementById('gridDensityValue').textContent = this.params.gridDensity;
                // document.getElementById('zoomValue').textContent = this.view.zoom.toFixed(1); // Removed
                document.getElementById('heightRangeValue').textContent = this.params.heightRange.toFixed(1) + 'x';
                document.getElementById('seaLevelValue').textContent = this.params.seaLevel.toFixed(2);
                document.getElementById('noiseScaleValue').textContent = this.params.noiseScale;
                document.getElementById('octavesValue').textContent = this.params.octaves;
                document.getElementById('persistenceValue').textContent = this.params.persistence.toFixed(2);
                document.getElementById('lacunarityValue').textContent = this.params.lacunarity.toFixed(1);
            }

            initEvents() {
                const requestRender = () => {
                    this.needsRender = true;
                };

                const controls = [
                    'gridDensity', 'heightRange', 'seaLevel',
                    'noiseScale', 'octaves', 'persistence', 'lacunarity'
                ];
                controls.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('input', e => {
                            this.params[id] = parseFloat(e.target.value);
                            if (id === 'seaLevel') this.updateBiomeRanges();
                            if (id === 'gridDensity' || id === 'heightRange') {
                                // Force full redraw if tile size or height scale changes
                                this.clearGrid();
                            }
                            this.updateValueDisplays();
                            requestRender();
                        });
                    }
                });
                // Removed Zoom slider event listener

                const colorIds = ['DeepWater', 'ShallowWater', 'Sand', 'Grass', 'Forest', 'Rock', 'Snow'];
                colorIds.forEach(id => {
                    const colorInput = document.getElementById(`color${id}`);
                    const preview = document.getElementById(`preview${id}`);
                    if (colorInput && preview) {
                        const key = id.charAt(0).toLowerCase() + id.slice(1);
                        colorInput.addEventListener('input', e => {
                            this.params.colors[key] = e.target.value;
                            preview.style.backgroundColor = e.target.value;
                            requestRender();
                        });
                    }
                });

                document.getElementById('preset-select').addEventListener('change', e => {
                    this.setPreset(e.target.value);
                    this.clearGrid(); // Force redraw on preset change
                    requestRender();
                });

                document.getElementById('regenerate').addEventListener('click', () => {
                    this.initNoise();
                    this.clearGrid(); // Force redraw with new noise
                    requestRender();
                });

                document.addEventListener('keydown', e => {
                    const key = e.key.toLowerCase();
                    if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'w', 'a', 's', 'd'].includes(key)) {
                         this.keysPressed[key] = true;
                         e.preventDefault(); // Prevent browser scroll
                    } else {
                         switch(key) {
                            // case '+': case '=': // Zoom removed
                            // case '-': case '_': // Zoom removed
                            //     break;
                            case 'r':
                                this.initNoise();
                                this.clearGrid();
                                requestRender();
                                break;
                            case 'c': this.toggleControls(); break;
                        }
                    }
                });
                document.addEventListener('keyup', e => {
                     const key = e.key.toLowerCase();
                     if (key in this.keysPressed) {
                         this.keysPressed[key] = false;
                     }
                });

                document.addEventListener('mousedown', e => {
                    if (e.target.closest('#controls') || e.target.closest('#toggle-controls')) return;
                    if (e.button === 0) {
                        this.view.isDragging = true;
                        [this.view.lastX, this.view.lastY] = [e.clientX, e.clientY];
                        document.body.style.cursor = 'grabbing';
                    }
                });

                document.addEventListener('mousemove', e => {
                    if (this.view.isDragging) {
                        const dx = e.clientX - this.view.lastX;
                        const dy = e.clientY - this.view.lastY;
                        // Panning moves the view opposite to mouse drag
                        this.view.x -= dx; // No zoom adjustment needed
                        this.view.y -= dy;
                        [this.view.lastX, this.view.lastY] = [e.clientX, e.clientY];
                        requestRender();
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (this.view.isDragging) {
                        this.view.isDragging = false;
                        document.body.style.cursor = '';
                    }
                });
                 document.addEventListener('mouseleave', () => {
                    if (this.view.isDragging) {
                        this.view.isDragging = false;
                        document.body.style.cursor = '';
                    }
                });

                // Removed Mouse wheel zoom listener

                document.getElementById('toggle-controls').addEventListener('click', () => this.toggleControls());

                window.addEventListener('resize', () => {
                    clearTimeout(window.resizeTimer);
                    window.resizeTimer = setTimeout(() => {
                        if (window.terrainApp) {
                            this.clearGrid(); // Force redraw on resize
                            requestRender();
                        }
                    }, 150); // Slightly longer debounce for resize
                });
            }

            toggleControls() {
                 const controls = document.getElementById('controls');
                 const toggleBtn = document.getElementById('toggle-controls');
                 const helpText = document.getElementById('help-text');
                 controls.classList.toggle('collapsed');
                 if (controls.classList.contains('collapsed')) {
                     toggleBtn.textContent = '▶';
                     toggleBtn.title = 'Show Controls Panel (C)';
                     helpText.style.left = '8px'; // Update help text position
                 } else {
                     toggleBtn.textContent = '◀';
                     toggleBtn.title = 'Hide Controls Panel (C)';
                     helpText.style.left = '310px'; // Update help text position
                 }
            }

            updateLoop(timestamp) {
                // Ensure lastTimestamp is initialized
                if (this.lastTimestamp === 0) this.lastTimestamp = timestamp;

                const deltaTime = Math.min(timestamp - this.lastTimestamp, 50); // Cap delta time (ms) to prevent large jumps
                this.lastTimestamp = timestamp;

                let moved = false;
                const moveSpeed = this.BASE_MOVE_SPEED * (deltaTime / 1000); // pixels per frame

                let dx = 0;
                let dy = 0;

                if (this.keysPressed['arrowup'] || this.keysPressed['w']) dy -= 1;
                if (this.keysPressed['arrowdown'] || this.keysPressed['s']) dy += 1;
                if (this.keysPressed['arrowleft'] || this.keysPressed['a']) dx -= 1;
                if (this.keysPressed['arrowright'] || this.keysPressed['d']) dx += 1;

                if (dx !== 0 || dy !== 0) {
                    const length = Math.sqrt(dx * dx + dy * dy);
                    dx = (dx / length) * moveSpeed;
                    dy = (dy / length) * moveSpeed;

                    this.view.x += dx;
                    this.view.y += dy;
                    moved = true;
                }

                if (moved) {
                    this.needsRender = true;
                }

                if (this.needsRender) {
                    this.render();
                    this.needsRender = false;
                }

                this.animationFrameId = requestAnimationFrame(ts => this.updateLoop(ts));
            }

            // Removed adjustZoom function

            updateBiomeRanges() {
                const sea = this.params.seaLevel;
                this.params.biomeRanges = {
                    deepWater: sea * 0.75, shallowWater: sea, sand: sea + 0.05,
                    grass: sea + 0.20, forest: sea + 0.45, rock: sea + 0.65, snow: 1.0
                };
                for (const key in this.params.biomeRanges) {
                    this.params.biomeRanges[key] = Math.max(0, Math.min(1, this.params.biomeRanges[key]));
                 }
            }

             setPreset(preset) {
                this.params.colorMode = preset === 'bw' ? 'bw' : 'atlas';
                const presets = {
                    // Presets now use heightRange as 1.0 (base)
                    terrain: {
                        colors: { deepWater: '#1a5cb3', shallowWater: '#3a7ccb', sand: '#f2d2a9', grass: '#7dab6e', forest: '#4a6b3e', rock: '#8c7d70', snow: '#f0f0f0' },
                        noise: [120, 4, 0.5, 2, 1.0, 0.38] // scale, oct, pers, lac, heightScale, sea
                    },
                    atlas: {
                        colors: { deepWater: '#0f2c4a', shallowWater: '#1a4a7a', sand: '#e8d5a8', grass: '#6b8c42', forest: '#3a5a2a', rock: '#6a5a4a', snow: '#d0e0f0' },
                        noise: [150, 5, 0.6, 2.1, 1.0, 0.35]
                    },
                    realistic: {
                        colors: { deepWater: '#0a2342', shallowWater: '#1a4a7a', sand: '#d7c9aa', grass: '#5a8f3d', forest: '#2d5a3a', rock: '#7a6a5a', snow: '#f0f8ff' },
                        noise: [250, 6, 0.55, 2.2, 1.2, 0.40] // Slightly higher default height scale
                    },
                    mars: {
                        colors: { deepWater: '#5a3a3a', shallowWater: '#7c5a5a', sand: '#c1876b', grass: '#9c6a52', forest: '#7a4a3a', rock: '#5a3a3a', snow: '#d4b4a4' },
                        noise: [180, 5, 0.7, 2.5, 1.4, 0.15] // Higher height scale, low sea
                    },
                    islands: {
                        colors: { deepWater: '#1a3e7a', shallowWater: '#2a5c9a', sand: '#f2d2a9', grass: '#7dab6e', forest: '#4a6b3e', rock: '#8c7d70', snow: '#f0f0f0' },
                        noise: [90, 4, 0.45, 1.9, 0.8, 0.48] // Lower height scale, high sea
                    }
                };

                 if (preset !== 'bw') {
                     const p = presets[preset] || presets['atlas'];
                     Object.assign(this.params.colors, p.colors);
                     [
                        this.params.noiseScale, this.params.octaves, this.params.persistence,
                        this.params.lacunarity, this.params.heightRange, this.params.seaLevel
                     ] = p.noise;
                    this.initDOM(); // Update all UI elements
                 } else {
                     // If BW, reset height range to 1.0 perhaps? Or keep the current one? Let's keep it.
                     // Reset colors doesn't matter for BW mode.
                     this.updateValueDisplays(); // Update sliders if only mode changed
                 }

                this.updateBiomeRanges();
            }


            fractalNoise(worldX, worldY) {
                let value = 0, amplitude = 1, frequency = 1, maxValue = 0;
                // Removed effectiveScale, use noiseScale directly
                const scale = this.params.noiseScale;

                for (let i = 0; i < this.params.octaves; i++) {
                    // Added small offsets to each octave sample to break up grid artifacts
                    const offX = (i + 1) * 100.123;
                    const offY = (i + 1) * 50.456;
                    const sampleX = (worldX + offX) * frequency / scale;
                    const sampleY = (worldY + offY) * frequency / scale;

                    const noiseValue = this.perlin.get(sampleX , sampleY);

                    value += noiseValue * amplitude;
                    maxValue += amplitude;
                    amplitude *= this.params.persistence;
                    frequency *= this.params.lacunarity;

                    if (amplitude < 0.01) break;
                }

                const normalizedValue = value / maxValue;
                // Apply height range scaling here before returning
                const scaledValue = normalizedValue * this.params.heightRange;
                return Math.max(-1, Math.min(1, scaledValue)); // Clamp final scaled value
            }

            getTerrainColor(heightValue) {
                const normalized = (heightValue + 1) / 2; // Map -1..1 to 0..1
                const ranges = this.params.biomeRanges;
                const colors = this.params.colors;

                // Handle potential division by zero if ranges are identical
                const safeDiv = (a, b) => (b === 0 ? 1e9 : a / b); // Return large number if divisor is 0

                if (normalized <= ranges.deepWater) return colors.deepWater;
                if (normalized <= ranges.shallowWater)
                    return this.blendColors(colors.deepWater, colors.shallowWater,
                        safeDiv(normalized - ranges.deepWater, ranges.shallowWater - ranges.deepWater));
                if (normalized <= ranges.sand)
                    return this.blendColors(colors.shallowWater, colors.sand,
                        safeDiv(normalized - ranges.shallowWater, ranges.sand - ranges.shallowWater));
                if (normalized <= ranges.grass)
                    return this.blendColors(colors.sand, colors.grass,
                         safeDiv(normalized - ranges.sand, ranges.grass - ranges.sand));
                if (normalized <= ranges.forest)
                    return this.blendColors(colors.grass, colors.forest,
                        safeDiv(normalized - ranges.grass, ranges.forest - ranges.grass));
                if (normalized <= ranges.rock)
                    return this.blendColors(colors.forest, colors.rock,
                        safeDiv(normalized - ranges.forest, ranges.rock - ranges.forest));

                // Use explicit snow range if defined, otherwise blend rock to snow up to 1.0
                 if (ranges.snow && normalized <= ranges.snow && ranges.snow > ranges.rock)
                     return this.blendColors(colors.rock, colors.snow,
                        safeDiv(normalized - ranges.rock, ranges.snow - ranges.rock));

                return colors.snow;
            }


            blendColors(c1, c2, ratio) {
                ratio = Math.max(0, Math.min(1, ratio));
                if (isNaN(ratio)) ratio = 0; // Safety check

                const r1 = parseInt(c1.substring(1, 3), 16);
                const g1 = parseInt(c1.substring(3, 5), 16);
                const b1 = parseInt(c1.substring(5, 7), 16);
                const r2 = parseInt(c2.substring(1, 3), 16);
                const g2 = parseInt(c2.substring(3, 5), 16);
                const b2 = parseInt(c2.substring(5, 7), 16);

                const r = Math.round(r1 + (r2 - r1) * ratio);
                const g = Math.round(g1 + (g2 - g1) * ratio);
                const b = Math.round(b1 + (b2 - b1) * ratio);

                return `#${(1 << 24 | r << 16 | g << 8 | b).toString(16).slice(1).padStart(6, '0')}`;
            }

            clearGrid() {
                 const container = document.getElementById('heightmap');
                 while (container.firstChild) {
                    container.removeChild(container.firstChild);
                 }
                 this.tileCache = []; // Clear cache if used (not strictly needed with current approach)
                 this.needsRender = true; // Ensure it re-renders
            }

            render() {
                const container = document.getElementById('heightmap');
                const width = window.innerWidth;
                const height = window.innerHeight;

                const tileSize = Math.max(5, this.params.gridDensity);

                const numCols = Math.ceil(width / tileSize) + 2; // Extra buffer for smoother panning
                const numRows = Math.ceil(height / tileSize) + 2;

                container.style.gridTemplateColumns = `repeat(${numCols}, ${tileSize}px)`;
                container.style.gridTemplateRows = `repeat(${numRows}, ${tileSize}px)`;
                // Set container size explicitly to match grid
                container.style.width = `${numCols * tileSize}px`;
                container.style.height = `${numRows * tileSize}px`;


                const startCol = Math.floor(this.view.x / tileSize);
                const startRow = Math.floor(this.view.y / tileSize);
                // Calculate offset to keep the top-left visually static during panning
                const offsetX = -(this.view.x % tileSize);
                const offsetY = -(this.view.y % tileSize);


                // Use transform for potentially smoother panning than top/left
                container.style.transform = `translate(${offsetX}px, ${offsetY}px)`;

                const totalTiles = numCols * numRows;

                let tiles = Array.from(container.children);
                if (tiles.length !== totalTiles) {
                    // If counts differ, fully rebuild the grid for simplicity now
                    this.clearGrid(); // Clear existing
                    const fragment = document.createDocumentFragment();
                    for (let i = 0; i < totalTiles; i++) {
                        const tile = document.createElement('div');
                        tile.className = 'tile';
                        fragment.appendChild(tile);
                    }
                    container.appendChild(fragment);
                    tiles = Array.from(container.children); // Refresh the list
                }


                let tileIndex = 0;
                for (let r = 0; r < numRows; r++) {
                    for (let c = 0; c < numCols; c++) {
                        const tile = tiles[tileIndex++];
                        if (!tile) continue;

                        const worldX = (startCol + c) * tileSize; // Use corner for noise consistency
                        const worldY = (startRow + r) * tileSize;

                        const noiseValue = this.fractalNoise(worldX, worldY);

                        if (this.params.colorMode === 'bw') {
                            const grayValue = Math.floor(((noiseValue + 1) / 2) * 255);
                            tile.style.backgroundColor = `rgb(${grayValue},${grayValue},${grayValue})`;
                            tile.title = `Val: ${noiseValue.toFixed(3)}`;
                        } else {
                            tile.style.backgroundColor = this.getTerrainColor(noiseValue);
                            const displayHeight = ((noiseValue + 1) / 2).toFixed(3);
                            tile.title = `H: ${displayHeight}`;
                        }
                    }
                }

                document.getElementById('position-display').textContent =
                    `X: ${Math.round(this.view.x)}, Y: ${Math.round(this.view.y)}`;
            }
        }

        window.addEventListener('load', () => {
            window.terrainApp = new TerrainGenerator();
        });

        window.addEventListener('beforeunload', () => {
             if (window.terrainApp && window.terrainApp.animationFrameId) {
                cancelAnimationFrame(window.terrainApp.animationFrameId);
            }
        });

    </script>
</body>
</html>
